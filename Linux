------------------------------------------------------------------------------------------------------------------------------------------------------------------

lspci - 

via this command, we can check the PCI devices detected via kernel

lsusb - 

via this command, we can check the usb devices attached to the system, detected by kernel

Go to /dev

To check all the hardware devices detected by kernel and the names provided to the devices. The names to the devices is being provided by 'udev' which runs in 
the background and provide the names. If the distro allows, we can update the rules to provide the names.

Go to /etc/udev 

To check all the rules via which 'udev' service provides the names to the devices.

lsmod -

via this command, we can check all the modules loaded with kernel, modules are the drivers which are needed so that the hardware can work. When kernel detects
the hardware, it gives a name, but in order for hardware to work, it needs a driver to be present.

rmmod -

via this command, we can remove the modules as well, so the hardware will be there but kernel won't use the hardware as the module(driver) is being removed.
But this change is temporary, when the os reboot,the driver will be loaded again. To make this change permanent, we need to make an entry in the blacklist file.

/etc/modprobe.d

go to this directory and there will be some backlisted files, make an entry in the file for hardware to be loaded, and it will be permanent.

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Running Linux in VM

- The names assigned by udev will be different
- Might need to install some additional tools so that Linux works well
- Need to look for shut down options to make sure the machine is actually going to sleep

------------------------------------------------------------------------------------------------------------------------------------------------------------------

Linux Boot Process -

Below are the five stages of Linux Boot Process.

1. BIOS/UEFI (Basic I/O system)

2. MBR/GPT (Master Boot Record)

3. GRUB2 (Grand Unified Bootloader)

4. Initrd / Kernel

5. systemd

Files are present in the /boot directory.

GRUB picks up the location to boot the OS. It there are more than one OS,then it will show all the option to choose from. 

/etc/default/grub   --> This file has settings defined for the grub file. If you change this file, run 'update-grub' afterwards to update /boot/grub/grub.cfg

/etc/grub.d  --> This contains files which GRUB2 will combine and compile. We can edit these files


------------------------------------------------------------------------------------------------------------------------------------------------------------------

Terminal on Linux -

Terminal is the UI which we can use to execute the commands. Under the hood, the terminal uses a Shell, it might be bash, zsh or some other shell.

ps (processes show) - run this command to see which shell is being running

uname (unix name) - this command will show the os



------------------------------------------------------------------------------------------------------------------------------------------------------------------

Managing Processes -

When Linux OS boots, it will start a lot of processes. Each process is assigned a PID (process identifier). The process starts and finishes and that PID number 
is not assigned again to another process, so you will see the gaps in the PIDs.

ps - this command will show the processes for the current user
ps -aux : this command will show all the processes for all the users across machine
top - this command will show the processes who are consuming more CPU/Memory
free - this command will show the free resources on the machine


--> We can put some interactive programs to background and bring to foreground when need to work again for e.g. if we are working on editing a file via 
    vim, then while working on vim, use command 'ctrl + z' and it will bring the vim application to background. 
    We can check all the jobs in background via 'jobs' command and can bring the application to foreground via '%1' command.
    There are 'fg' and 'bg' commands as well to put application to foreground & background.
    But this is for interactive applications and once we will close the terminal, there applications will be close as well.
    
    If we have to run the services in the background, then we need to use 'systemctl' command which is being controlled by 'systemd'


------------------------------------------------------------------------------------------------------------------------------------------------------------------

Execution Priorities -

NOTE: In the above setion we have seen that we can put processes in the background by using 'ctrl + z', but this command can keep the process running
or might stop the process. If we want the process to keep running in background then use '&' at the end of command.

When Linux OS starts, it executes a lot of processes and on top of that the user can also runs the processes. Linux kernel treats all the processes
equally so each process gets it's turn for CPU usage. But there might be scenarios where the user would like to provide a priority to a particular 
process, so in that case the process can be started with 'nice' command. The syntax is:

nice -n <n> command

The priority can go from -20 to 19

The less the priority number, the more priority the process will get, like if the priority number is '-10' then the process will take priority from '+10'

There is a default priority of each distro, so suppose the default priority is 10, then the general users can run the process with priority 10 or more, but
only admin can run the processes with priorty 9 or less

If need to amend the priority while process is running, use below command:

renice -n <n> PID -u <username>



Kill a Process:
  - run 'top' command, use 'k' and provide the PID number to kill the process
  - run the command 'kill <PID>'
  
If we run 'kill -l' , we can see all the options, but three are main:
  - number1 'SIGHUP', (Signal hangup) it is asking the process to reset or reload
  - number9 'SIGKILL' , it will kill the process
  - number15 'SIGTERM', it will ask the process to terminate
  
kill -9 <PID>


We can also kill all the threads of a particular process by name and it will kill the process for all the users: 'killall chrome'


------------------------------------------------------------------------------------------------------------------------------------------------------------------


nano editor - We can open more than one buffer(files) at the same time in nano and can move around to work on the files.

while doing search/replace, there is no undo option in nano, so it's better to take a backup of file before doing search/replace.

vi/vim editor - run command ': set number' so that the file will display the line numbers

y - yank (copy) the line
p - put the line

ZZ - might be used in place of ':wq'

:e! - to undo the changes and reload the file from disk


------------------------------------------------------------------------------------------------------------------------------------------------------------------

Customizing Bash -

Bash configuration files are present at two places:
    - Configuration files local for the User, these are available in home directory(.bashrc, .profile)
    - Global configuration files(these are present in /etc directory)
    
    
- We can create the variables in .bashrc file, but those will be local to shell, if need global variables, put export while declaring the variable
- We can create the alias in the .bashrc file
- We can also create the functions in the .bashrc file



------------------------------------------------------------------------------------------------------------------------------------------------------------------

Piping - 

Many newer commands supprot piping, but some older command doesn't, like mkdir.
If we make a file and input the folders which we have to make and pipe the file to mkdir, it will not work.

cat foldernames.txt | mkdir 

the above command will give an error.

We can use 'xargs' which support piping and will do the job.

cat foldernames.txt | xargs mkdir


------------------------------------------------------------------------------------------------------------------------------------------------------------------

Redirect - 

- If we don't need any output, we can redirect that to /dev/null. Whatever goes to /dev/null, that is gone.

find / -name *.doc 2> /dev/null

- If need to write the output to screen and to the file, use the 'tee' command.


find / -name *.doc 2> /dev/null | tee list.txt

- While doing sort, it sorts on many factors and as the output of 'ls -lh' have incosistent output means the spaces are not consistent, so it is hard for
  sort to analyze each line. We can use 'tr' command in these situations
  
  ls -lh | tr -s " " "      " | sort -r -t "        " -k 9
  
  (to use tab in bash shell use 'ctrl +v + tab'
  
  
- the above command will provide all the columns in the output, if we just need only few columns, use the 'cut'command

  ls -lh | tr -s " " "      " | sort -r -t "        " -k 9 | cut -d "       " -f 5,9
  
  
- Use 'egrep' if need to use regular expression with grep


------------------------------------------------------------------------------------------------------------------------------------------------------------------

Working with checksums -

- To check which checksum utility are present use,
    ls /usr/bin/*sum
    
- Checksums are being used to ensure that the file is not modified during transmission

- 'md5sum' is not considered much secure

- 'shasum' is considered to be more secure, it has different versions like 'sha128sum' 'sha256sum' 'sha512sum'

- The bigger the number, the more digits it will produce, the more diffucult to break it

- But the bigger number will take more time to create the checksum for bigger files, so need to make a balance



------------------------------------------------------------------------------------------------------------------------------------------------------------------

Locating Files/Binaries:

- We can use below commands:

        - type: it will tell whether the command is binary or function
           'type vim'
        - locate: it maintains a database, so it takes a lot of harddisk space and database needs to be updated so that this can work fine
           ' locate vim'
        - whereis: it searches in the $PATH and give all the instances, but won't tell which one will be executed
           ' whereis vim'
        - which: it searches in the $PATH and will give the first hit, which will eventually be executed by Bash
           ' which vim'
           
           
     

- Find Command (check that in this command we use '-name' instead of '--name':

    - This command is useful to search the files with name/size/etc...
    - 'find / -name *.pdf'
    - 'find / -size +20M'



- 'Grep -r' command to find the files:
    - We can use the 'grep -r' command to find the files as well based on the content
    - Use 'grep -r "Test' /
    - In this command, we first provide the word which needs to be searched and then the path, this is opposited to find command



------------------------------------------------------------------------------------------------------------------------------------------------------------------

Hard and Soft Link -

- Hard link points to a specific raw data, so it can't be created for a directory.
- Hard Link can only be created with the same volume/same harddisk
- After file permissions there is a number, that number tells how many hardlinks are there for a file
- To create the hardlink, 'ln text.txt text-link.txt'

- Soft link points to a path, so soft link can be created for a directory
- To create the softlink for a file, 'ln -s text.txt text-link.txt'
- To create a softlink for a directory, 'ln -s /home/Desktop/Data/Linux/Work /home/medha'



------------------------------------------------------------------------------------------------------------------------------------------------------------------

File Ownership -

- Whenever we create a new file/directory, it picks up the owner/group information of the user who is creating the file/directory
- If we run the 'id' command, we can see the owner/group id, this is where system picks up the information and assign to the new file/directory
- The owner is important for a file/directory, as if we remove all the permissions from file/directory, then also the owner can access the file/directory
- To change the owner of a file/directory,
    - chown <new-owner> file
- To change the owner/group of a file/directory,
    - chown <new-owner> : <new-group> file
- To change the group of a file/directory,
    - chgrp <new-group> file


- If we change the owner of a directory, the files created inside the directory doesn't inherit the owner, but files inherit the permissions of a directory
- If we want that the new files created inside a directory inherit the group of the directory, we need to use the sticky bit
    - chmod g+s <directory>
- We can verify whether a directory has sticky bit set by looking into the directory permissions,
    - drwxrwsrwx 1 root root 4 Dec 10:49 new-file.txt
    - We can see that in the group permissions, there is a 's' , which indicates that sticky bit applied on the group
    - sticky bit only set the group inside the directory for the new files created, not on the existing files
    - if we copy a file to the directory, where sticky bit is applied, it will set the group of the file to the same as directory group, as copy creates a new file
    - if we move a file to the directory, where sticky bit is applied, it will not a file to the directory, where sticky bit is applied, as move doesn't creates a new file
    



POSIX Based file permissions - 


- When we create a new directory, it gets some default permissions, but from where it gets the permission,
    - it can get the permissions from /etc/profile
    - or the permissions might be in .bashrc
    - but eventually all the permissions are maintained by 'umask' i.e. umask provides the default permissions
    



ACL (Access Control List) or FACL (File Access Control List) Based file permissions - 


fstab - filesystem table


- The challange with POSIX based file permissions are, that they support one owner, one group and others.
- ACL allows a list of users/groups and we can define what permission each user/group will have, this is not possible with POSIX based permissions.
- Now as each computer is connected to network, we would like to have more than one user or group to have access to a file/directory.
- When we assign the FACL based permissions, the POSIX permission will not go away
- On some distro, the ACL might be a active by default or we might need to activate the ACL
- When we mount a volume, there we need to define whether we want ACL to be active
- We can check this at /etc/fstab
- We can check the defaults of a volume by:
    $ tune2fs -l /dev/sda5


- Two main commands to work with ACLs:
    - getfacl
    - setfacl
    
    
    
- To check whether the ACLs are applied to a Directory/File
    - there will be a '+' sign at the end of permissions, like
        drwxrwxrwx+ 1 .......
- To set the permissions:
    $ setfacl -m u:<username>:rw <filename>
    $ setfacl -m g:<groupname>:rw <filename>

- To check the FACL permissions:
    $ getfactl <filename>

- But when we set the ACL by this way on directory, the files created inside the directory will not inherit these permissions
    $ setfacl -m g:<groupname>:r <directory>
    
- So we need to set the FACL by some extra option so that the permissions will be inherited by files created inside the directory
    $ setfacl -m d:g:<groupname>:r <directory>
    
- The 'd' option is the default permissions of a directory which the new files will inherit from directory

- when we set the FACL, it will create a mask (max permissions) as well, mask is a set of permissions i.e.the maximum permission a user/group can have.














